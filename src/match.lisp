
(defun combinator-to-tree (comb)
  (let* ((lst (cons (cs-name (cb-spec comb))
                    (mapcar #'combinator-to-tree (reverse (cb-params comb)))))
         (norm (if (null lst)
                   nil
                   (if (= (length lst) 1)
                       (car lst)
                       (reduce (lambda (body el)
                                 (list body el))
                               (cddr lst)
                               :initial-value (list (first lst) (second lst)))))))
    norm))

(defun match-combinators (pattern body)
  (let ((match-tab (make-hash-table :test #'eq))
        (match-list nil))
    (labels ((add-match (var body)
               (let ((old (gethash var match-tab)))
                 (if old
                     (if (equalp old body)
                         t
                         nil)
                     (progn 
                       (setf (gethash var match-tab)
                             body)))))
             (var-p (a)
               (and (symbolp a)
                    (char= (elt (symbol-name a) 0) #\?)))
             (match-node (pnode bnode)
               (cond ((and (atom pnode)
                           (var-p pnode))
                      (add-match pnode bnode))
                     ((and (atom pnode)
                           (atom bnode))
                      (equalp pnode bnode))
                     ((and (listp pnode)
                           (listp bnode))
                      (every #'match-node pnode bnode))
                     (t nil))))
      (let ((res (match-node pattern body)))
        (when res
          (maphash (lambda (key value)
                     (push (list key value) match-list))
                   match-tab)
          (values res match-list))))))